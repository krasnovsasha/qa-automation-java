Руководство по практическим заданиям
====================================
При выполнении тренировок настоятельно рекомендуем такую последовательность работы:
1. Внимательно прочитайте раздел Дано
1. Проведите инспекцию заданного кода
1. В случае вопросов обращайтесь к менторам
1. Далее внимательно прочитайте раздел Цели
1. Попробуйте прикинуть в уме, как будет выглядеть итоговое решение
1. Распланируйте последовательность задач: план, что конкретно необходимо реализовать в коде
1. Проведите оценку: сколько это займет?
1. И только в случае существенных трудностей обратитесь к разделу Задачи
1. В разделе Задачи вы найдете готовый конкретный план действий
1. Проведите внутреннюю ретроспективу: что Вы забыли или не учли в собственном плане действий по сравнению с готовым предложенным планом?


Тренировка #01-1: git everyday workflow
==============

Дано
----
- [ ] Данный git-репо на github.com


Цели
----
- [ ] Сделан персональный fork данного репо под своей учетной записью github
- [ ] В этом fork создан pull request: dev -> main c файлом owner.md c ФИО участника
- [ ] Сообщения коммитов следуют соглашению [Conventional Commits](https://www.conventionalcommits.org/ru/v1.0.0-beta.4/)

Задачи
------
- [ ] Существует персональная учетная запись на github
- [ ] Сделан персональный fork данного репо под своей учетной записью github
- [ ] Персональный fork склонирован локально с помощью IDEA
- [ ] Создана ветка dev
- [ ] В ветке dev в корне проекта создан файл owner.md c ФИО участника обучения
- [ ] Произведена фиксация изменений (commit)
- [ ] Произведена публикация изменений (push)
- [ ] Создан pull request изменений из dev в main

Как проверить
-------------
- [ ] На github на странице вашего fork в разделе pull requests наблюдается открытый PR с верным содержимым:
- файл owner.md c ФИО участника
- сообщение коммита следует соглашению



Тренировка #01-2: simple java app compiling
==============

Дано
----
- [ ] Данный git repo с готовой кодовой базой (sourcepath) в папке src/main/java

Цели
----
- [ ] Успешная компиляция простого приложения
- [ ] Успешный запуск простого приложения


Задачи
------
- [ ] В командной оболочке перейдите в папку с заготовкой исходников простого приложения
- [ ] Проведите компиляцию из командной оболочки
- [ ] При необходимости исправьте ошибки компиляции
- [ ] Проведите запуск приложения из командной оболочки


Как проверить
-------------
- [ ] Приложение скомпилировалось без вывода компилятора об ошибках
- [ ] При запуске в командной оболочке наблюдается вывод
```shell
Hello world!
```


Тренировка #01-3: сборка проекта с помощью maven
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта 
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java
- [ ] Конфигурационный файл сборки проекта pom.xml

Цели
----
- [ ] Проведена успешная сборка проекта
- [ ] Проведен успешный запуск полученного приложения

Задачи
------
- [ ] В командной оболочке перейдите в папку проекта
- [ ] Выполните сборку до фаз clean и verify
```shell
mvn clean verify
```
- [ ] Выполните запуск приложения из текущей папки labguide
```shell
 java -classpath target/app-1.0-SNAPSHOT.jar Application
```


Как проверить
-------------
- [ ] Приложение скомпилировалось без вывода компилятора об ошибках
- [ ] При запуске в командной оболочке наблюдается вывод
```shell
Hello world!
```



Тренировка #03-1: Комментарии
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Описан контракт класса ConsolePrinter в javadoc-комментариях

Задачи
------
- [ ] В IDEA откройте ConsolePrinter
- [ ] Добавьте javadoc-комментарий, описывающий 
- назначение класса
- назначение метода
- входные параметры
- побочные эффекты
- автор

Как проверить
-------------
- [ ] В IDEA откройте класс Application
- [ ] Найдите использование класса ConsolePrinter
- [ ] Активируйте функцию Quick Documentation

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #03-2: управление кодовой базой с помощью пакетов
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Задано общее пространство имен для всех классов приложения: `com.tcs.edu`
- [ ] Классы, отвечающие за реализацию вывода, инкапсулированы в подпакет `printer`

Задачи
------
- [ ] Добавить для класса `Application` директиву `package com.tcs.edu`
- [ ] Добавить для класса `ConsolePrinter` директиву `package com.tcs.edu.printer`
- [ ] В классе `Application` использовать второй класс по его полному имени: добавить директиву `import com.tcs.edu.printer.ConsolePrinter`
- [ ] Выполните из консоли запуск приложения
```shell
 java -classpath target/app-1.0-SNAPSHOT.jar com.tcs.edu.Application
```

Как проверить
-------------
- [ ] Приложение успешно компилируется
- [ ] При запуске класса `Application` видим вывод в консоль
```shell
Hello World!
```

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #03-3: Собственные класс и метод
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Создан класс с ответственностью декорирования сообщений с операцией добавления к строке текущего времени
- класс приобщен в соответствующий пакет
- имена пакетов, классов, методов явно выражает намерение разработчика
- текущее время получено с помощью функции системной библиотеки Instant.now()
- склейка строк осуществлена с помощью конкатенации '+'

Задачи
------
- [ ] В sourcepath (src/main/java) cоздайте пакет com.tcs.edu.decorator
- [ ] Создайте класс com.tcs.edu.decorator.TimestampMessageDecorator
- [ ] Создайте статический метод decorate(String message), возвращающий String – обогащенную строку сообщения
- [ ] В методе возвращайте склееную строку, состоящую из результата функции Instant.now() и входного параметра метода – строки сообщения
- [ ] Импортируйте полное имя класса java.time.Instant 
- [ ] В основном классе приложения com.tcs.edu.Application выводите не сообщение, а результат обогащения этого сообщения

Как проверить
-------------
- [ ] Покрытие javadoc-комментариями класса и метода
- [ ] При запуске основного класса приложения вывод похож на следующий:
```shell
2022-03-04T05:29:23.020171Z Hello world!
```

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main



Тренировка #04-1: Переменная метода
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] В методе обогащения строки сообщения введена поясняющая переменная для повышения читабельности кода

Задачи
------
- [ ] В sourcepath (src/main/java) откройте метод decorate() класса com.tcs.edu.decorator.TimestampMessageDecorator
- [ ] Результат выражения склейки текущего времени и сообщения сохраняйте в переменную decoratedMessage типа String
- [ ] Возвращайте из метода значение этой переменной

Как проверить
-------------
- [ ] Покрытие javadoc-комментариями класса и метода
- [ ] При запуске основного класса приложения структура вывода не поменялась с прошлой версии кода

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main



Тренировка #04-2: Переменная класса
==============

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Добавлено глобальное состояние приложения: общая переменная с количеством выведенных сообщений
- [ ] В вывод сообщения добавлено так же, какое по счету это сообщение

Задачи
------
- [ ] В sourcepath (src/main/java) откройте класс com.tcs.edu.decorator.TimestampMessageDecorator
- [ ] Добавьте глобальную (static) переменную messageCount
- [ ] В методе вывода увеличивайте этот счетчик (оператор '++')
- [ ] При формировании итоговой строки обогащенного сообщения вначале добавляйте значение этого счетчика

Как проверить
-------------
- [ ] Для проверки корректности работы программы с состоянием необходимо воспроизвести необходимое состояние
- Единичного вывода теперь недостаточно
- Измените тестовый класс Application, чтобы было более одного вывода сообщения
- [ ] Убедитесь в корректности вывода счетчика
```shell
1 2022-03-04T05:29:23.020171Z Hello world!
2 2022-03-04T05:29:23.020172Z Hello world!
3 2022-03-04T05:29:23.020173Z Hello world!
```

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main



Тренировка #04-3: Вывод типов локальной переменной
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели 
----
- [ ] Упростить код обогащения сообщений с помощью автоматического вывода типа поясняющей переменной

Задачи
------
- [ ] В sourcepath (src/main/java) откройте метод decorate() класс com.tcs.edu.decorator.TimestampMessageDecorator
- [ ] Измените объявление поясняющей переменной decoratedMessage: вместо явного объявления типа переменной используйте var

Как проверить
-------------
- [ ] При запуске основного класса приложения структура вывода не поменялась с прошлой версии кода

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #04-4: Использование констант
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Защитить код обогащения сообщений от случайных ошибок: зафискировать значение поясняющей переменной

Задачи
------
- [ ] В sourcepath (src/main/java) откройте метод decorate() класс com.tcs.edu.decorator.TimestampMessageDecorator
- [ ] Измените объявление поясняющей переменной decoratedMessage: добавьте модификатор final

Как проверить
-------------
- [ ] Компилятор не позволит менять значение этой переменной (уже константы)
- [ ] При запуске основного класса приложения структура вывода не поменялась с прошлой версии кода

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main

---

Тренировка #05-1 [optional]: Использование функции `String.format()` 
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Использование форматирования строк по шаблону вместо конкатенации подстрок

Задачи
------
- [ ] Изучить документацию на `String.format()`
- [ ] Заменить конкатенацию подстрок на форматирование по шаблону

Как проверить
-------------
- [ ] При запуске основного класса приложения структура вывода не поменялась с прошлой версии кода

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #05-2: Постраничное форматирование вывода
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Задать в коде константу с количеством выводимых сообщений на "странице" 
- [ ] При выводе разделять "страницы"
```
---
```

Как проверить
-------------
- [ ] Вывод тестового сценария выглядит следующим образом (на примере размера "страницы" == 2)
```shell
1 2022-03-04T05:29:23.020171Z Hello world!
2 2022-03-04T05:29:23.020172Z Hello world!
---
3 2022-03-04T05:29:23.020173Z Hello world!
4 2022-03-04T05:29:23.020173Z Hello world!
---
5 2022-03-04T05:29:23.020173Z Hello world!
6 2022-03-04T05:29:23.020173Z Hello world!
---
```

Задачи
------
- [ ] В классе `com.tinkoff.edu.decorator.TimestampMessageDecorator` задекларировать и проинициализировать глобальную константу `PAGE_SIZE`
- [ ] В методе `decorate()` добавьте проверку на делимость номера текущего сообщения на размер страницы оператором `%`
- [ ] Если делится без остатка, добавьте к выводу строку разделения "страницы"
```
---
```

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


---


Тренировка #06-1: Уровни значимости сообщений с кодированием перечислением
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Введен перечислимый тип, кодирующий уровень значимости выводимых сообщений:
- MINOR
- REGULAR
- MAJOR
- [ ] В API процедуры вывода первым параметром добавлен уровень значимости выводимого сообщения
- [ ] При выводе к сообщению добавляем вконце уровень важности:
- MINOR: `()`
- REGULAR: `(!)`
- MAJOR: `(!!!)`

Как проверить
-------------
- [ ] Вывод тестового сценария выглядит следующим образом:
```shell
1 2022-03-04T05:29:23.020171Z Hello world! ()
2 2022-03-04T05:29:23.020172Z Hello world! (!)
---
3 2022-03-04T05:29:23.020173Z Hello world! (!)
4 2022-03-04T05:29:23.020173Z Hello world! (!!!)
---
5 2022-03-04T05:29:23.020173Z Hello world! ()
6 2022-03-04T05:29:23.020173Z Hello world! (!!!)
---
```

Задачи
------
- [ ] В пакете `com.tinkoff.edu.decorator` создать enum `Severity` значениями `MINOR, REGULAR, MAJOR` 
- [ ] Принять решение и задокументировать в javadoc, какой класс будет отвечать за строковое представление уровня важности 
- например, "REGULAR" -> "(!)"
- для отображения перечислимого типа в строку использовать конструкцию `switch`
- [ ] Если в дизайне системы появится несколько классов с разными аспектами декорирования, имеет смысл:
- разделять эти классы для поддерживаемости кодовой базы
- для удобства API и его использования имеет смысл ввести новый класс, "склеивающий" итоговую строку сообщения
- такие классы, объединяющие поведение из разных классов в итоговую бизнес-логику, в зависимости от окружающего контекста часто называются:
- Facade, Controller, Service – давайте выберем название `MessageService`
- [ ] Добавить в объединяющую операцию вывода первым параметром уровень значимости

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #06-2: Удобный вывод группы сообщений с varargs и foreach
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Добавить в API операции вывода возможность задать несколько сообщений 
- уровень значимости остается единым для всех этих сообщений
- API требует минимум одно сообщение для вывода (на этапе компиляции)

Как проверить
-------------
- [ ] Вывод тестового сценария остается неизменным с прошлой тренировки

Задачи
------
- [ ] Поменять сигнатуру метода `MessageService.print`
- `MessageService.print(Severity, String message, String... messages)`
- [ ] Реализовать процессинг vararg c помощью цикла foreach

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main

---

Тренировка #07-1: Вывод отсутствующего сообщения (null)
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- Оказывается, входные параметры не примитивных типов могут принимать граничное значение `null` 
- При попытке обратиться к полю или методу по такой ссылке возникает ошибка NPE
- [ ] Необходимо обеспечить корректную работу приложения в случае значения `null` входного параметра (в т.ч. любого из последовательности vararg)
- [ ] На данный момент null-значения просто игнорируем. В дальнейшем API будет возбуждать исключительную ситуацию.

Как проверить
-------------
- [ ] Передать последовательность параметров vararg, где присутствует null
- [ ] null-значения игнорируются, все остальные значения выводятся корректно (в соответствии с прошлыми требованиями) 
- [ ] API не выбрасывает никаких исключений

Задачи
------
- [ ] В логике процессинга входных параметров добавить проверку значения параметра на null
- [ ] Игнорировать обработку таких значений

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #07-2: Вывод последовательности строковых сообщений в режиме прямой и обратной сортировки (ASC/DESC)
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Добавить в API параметр, определяющий порядок вывода сообщений для последовательности строковых параметров vararg
- [ ] Старый API оставить, расширение API реализовать новыми перегружеными методами
- [ ] Код соответствует стилю кодирования и внутренней модели качества

Как проверить
-------------
- [ ] Для режима ASC вывод соответствует прошлым требованиям
- [ ] Для режима DESC сообщения из последовательности vararg выводятся в обратном порядке
```shell
1 2022-03-04T05:29:23.020171Z Hello world 6! ()
2 2022-03-04T05:29:23.020172Z Hello world 5! (!)
---
3 2022-03-04T05:29:23.020173Z Hello world 4! (!)
4 2022-03-04T05:29:23.020173Z Hello world 3! (!!!)
---
5 2022-03-04T05:29:23.020173Z Hello world 2! ()
6 2022-03-04T05:29:23.020173Z Hello world 1! (!!!)
---
```

Задачи
------
- [ ] Реализовать перечислимый тип `MessageOrder` с возможными значениями `ASC` и `DESC`
- [ ] Добавить параметр сортировки в API: `MessageService.print(Severity level, MessageOrder order, String message, String... messages)`
- [ ] Реализовать ветвление по значению параметра сортировки
- [ ] Для значения параметра сортировки `DESC` реализовать обратный цикл итерирования по последовательности vararg:
```
for(счетчик цикла от размера массива vararg - 1 до 0 с уменьшением счетчика на единицу) {
   параметр_типа_vararg[счетчик]
}
```

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main


Тренировка #07-3: Вывод строковых сообщений без дублирования (DISTINCT)
==========

Дано
----
- [ ] Данный git repo с заготовкой проекта
- [ ] Изменения ведутся в ветке dev
- [ ] Папочная структура проекта maven c готовой кодовой базой (sourcepath) src/main/java

Цели
----
- [ ] Добавить в API параметр, определяющий характер дублирования значений сообщений последовательности строковых параметров vararg  
- [ ] Старый API оставить, расширение API реализовать новыми перегружеными методами

Как проверить
-------------
- [ ] Для режима DOUBLES вывод соответствует прошлым требованиям, с дублированием
- [ ] Для режима DISTINCT сообщения из последовательности vararg выводятся без дублирования, даже если в параметре есть повторяющиеся сообщения
- [ ] Код соответствует стилю кодирования и внутренней модели качества

Задачи
------
- [ ] Реализовать перечислимый тип `Doubling` с возможными значениями `DOUBLES` и `DISTINCT`
- [ ] Добавить параметр дублирования в API: `MessageService.print(Severity level, MessageOrder order, Doubling doubling, String message, String... messages)`
- [ ] Реализовать ветвление по значению параметра дублирования
- [ ] Для значения параметра дублирования `DISTINCT` реализовать логику проверки на повтор выводимых сообщений:
- Описать массив выведенных сообщений: кратковременную (локальную) переменную типа массив строк и проинициализировать массивом, по размеру равным длине последовательности vararg
- После вывода сообщения сохранять выведенное сообщение как следующий элемент массива выведенных сообщений
- Перед выводом проверять сообщение на вхождение в массив выведенных сообщений и если сообщение уже выводилось, игнорировать его
- Проверку сообщения на вхождение в массив выведенных сообщений реализовать циклом с проверкой на эквивалентность 

Отправка на ревью
-----------------
- [ ] Изменения зафиксированы в ветке dev
- [ ] Сообщение коммита следует соглашению
- [ ] Создан PR в main

---